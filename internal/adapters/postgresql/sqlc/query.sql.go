// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (user_id, organization_id, action, resource_type, resource_id, details)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, organization_id, action, resource_type, resource_id, details, created_at
`

type CreateAuditLogParams struct {
	UserID         pgtype.UUID `json:"user_id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	Action         string      `json:"action"`
	ResourceType   string      `json:"resource_type"`
	ResourceID     pgtype.UUID `json:"resource_id"`
	Details        []byte      `json:"details"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.UserID,
		arg.OrganizationID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Details,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrganizationID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (project_id, name, slug)
VALUES ($1, $2, $3)
RETURNING id, project_id, name, slug, created_at, updated_at
`

type CreateEnvironmentParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Name      string      `json:"name"`
	Slug      string      `json:"slug"`
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (Environment, error) {
	row := q.db.QueryRow(ctx, createEnvironment, arg.ProjectID, arg.Name, arg.Slug)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (name, slug)
VALUES ($1, $2)
RETURNING id, name, slug, created_at, updated_at
`

type CreateOrganizationParams struct {
	Name string `json:"name"`
	Slug string `json:"slug"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization, arg.Name, arg.Slug)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (organization_id, name, slug, description)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, name, slug, description, created_at, updated_at
`

type CreateProjectParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Name           string      `json:"name"`
	Slug           string      `json:"slug"`
	Description    pgtype.Text `json:"description"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.OrganizationID,
		arg.Name,
		arg.Slug,
		arg.Description,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, full_name)
VALUES ($1, $2, $3)
RETURNING id, email, password_hash, full_name, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	FullName     string `json:"full_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash, arg.FullName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVariable = `-- name: CreateVariable :one
INSERT INTO variables (environment_id, key, value, is_secret)
VALUES ($1, $2, $3, $4)
RETURNING id, environment_id, key, value, is_secret, created_at, updated_at
`

type CreateVariableParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Key           string      `json:"key"`
	Value         string      `json:"value"`
	IsSecret      pgtype.Bool `json:"is_secret"`
}

func (q *Queries) CreateVariable(ctx context.Context, arg CreateVariableParams) (Variable, error) {
	row := q.db.QueryRow(ctx, createVariable,
		arg.EnvironmentID,
		arg.Key,
		arg.Value,
		arg.IsSecret,
	)
	var i Variable
	err := row.Scan(
		&i.ID,
		&i.EnvironmentID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVariable = `-- name: DeleteVariable :exec
DELETE FROM variables
WHERE environment_id = $1 AND key = $2
`

type DeleteVariableParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Key           string      `json:"key"`
}

func (q *Queries) DeleteVariable(ctx context.Context, arg DeleteVariableParams) error {
	_, err := q.db.Exec(ctx, deleteVariable, arg.EnvironmentID, arg.Key)
	return err
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, name, slug, created_at, updated_at FROM organizations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrganization(ctx context.Context, id pgtype.UUID) (Organization, error) {
	row := q.db.QueryRow(ctx, getOrganization, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProject = `-- name: GetProject :one
SELECT id, organization_id, name, slug, description, created_at, updated_at FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, password_hash, full_name, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, full_name, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT id, project_id, name, slug, created_at, updated_at FROM environments
WHERE project_id = $1
ORDER BY name
`

func (q *Queries) ListEnvironments(ctx context.Context, projectID pgtype.UUID) ([]Environment, error) {
	rows, err := q.db.Query(ctx, listEnvironments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Environment
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name, slug, created_at, updated_at FROM organizations
ORDER BY name
`

func (q *Queries) ListOrganizations(ctx context.Context) ([]Organization, error) {
	rows, err := q.db.Query(ctx, listOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, organization_id, name, slug, description, created_at, updated_at FROM projects
WHERE organization_id = $1
ORDER BY name
`

func (q *Queries) ListProjects(ctx context.Context, organizationID pgtype.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjects, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, full_name, created_at, updated_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariables = `-- name: ListVariables :many
SELECT id, environment_id, key, value, is_secret, created_at, updated_at FROM variables
WHERE environment_id = $1
ORDER BY key
`

func (q *Queries) ListVariables(ctx context.Context, environmentID pgtype.UUID) ([]Variable, error) {
	rows, err := q.db.Query(ctx, listVariables, environmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Variable
	for rows.Next() {
		var i Variable
		if err := rows.Scan(
			&i.ID,
			&i.EnvironmentID,
			&i.Key,
			&i.Value,
			&i.IsSecret,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVariable = `-- name: UpdateVariable :one
UPDATE variables
SET value = $3, is_secret = $4, updated_at = CURRENT_TIMESTAMP
WHERE environment_id = $1 AND key = $2
RETURNING id, environment_id, key, value, is_secret, created_at, updated_at
`

type UpdateVariableParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Key           string      `json:"key"`
	Value         string      `json:"value"`
	IsSecret      pgtype.Bool `json:"is_secret"`
}

func (q *Queries) UpdateVariable(ctx context.Context, arg UpdateVariableParams) (Variable, error) {
	row := q.db.QueryRow(ctx, updateVariable,
		arg.EnvironmentID,
		arg.Key,
		arg.Value,
		arg.IsSecret,
	)
	var i Variable
	err := row.Scan(
		&i.ID,
		&i.EnvironmentID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
