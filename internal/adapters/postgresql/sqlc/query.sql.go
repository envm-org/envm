// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectMember = `-- name: AddProjectMember :one
INSERT INTO project_members (project_id, user_id, role)
VALUES ($1, $2, $3)
RETURNING project_id, user_id, role, created_at
`

type AddProjectMemberParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	UserID    pgtype.UUID `json:"user_id"`
	Role      string      `json:"role"`
}

func (q *Queries) AddProjectMember(ctx context.Context, arg AddProjectMemberParams) (ProjectMember, error) {
	row := q.db.QueryRow(ctx, addProjectMember, arg.ProjectID, arg.UserID, arg.Role)
	var i ProjectMember
	err := row.Scan(
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (user_id, action, resource_type, resource_id, details)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, action, resource_type, resource_id, details, created_at
`

type CreateAuditLogParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	Action       string      `json:"action"`
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
	Details      []byte      `json:"details"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.UserID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Details,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (project_id, name, slug)
VALUES ($1, $2, $3)
RETURNING id, project_id, name, slug, created_at, updated_at
`

type CreateEnvironmentParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Name      string      `json:"name"`
	Slug      string      `json:"slug"`
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (Environment, error) {
	row := q.db.QueryRow(ctx, createEnvironment, arg.ProjectID, arg.Name, arg.Slug)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (name, slug, description)
VALUES ($1, $2, $3)
RETURNING id, name, slug, description, created_at, updated_at
`

type CreateProjectParams struct {
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.Name, arg.Slug, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, full_name)
VALUES ($1, $2, $3)
RETURNING id, email, password_hash, full_name, password_reset_token, password_reset_expires_at, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	FullName     string `json:"full_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash, arg.FullName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVariable = `-- name: CreateVariable :one
INSERT INTO variables (environment_id, key, value, is_secret, path)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, environment_id, key, value, is_secret, path, created_at, updated_at
`

type CreateVariableParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Key           string      `json:"key"`
	Value         string      `json:"value"`
	IsSecret      pgtype.Bool `json:"is_secret"`
	Path          string      `json:"path"`
}

func (q *Queries) CreateVariable(ctx context.Context, arg CreateVariableParams) (Variable, error) {
	row := q.db.QueryRow(ctx, createVariable,
		arg.EnvironmentID,
		arg.Key,
		arg.Value,
		arg.IsSecret,
		arg.Path,
	)
	var i Variable
	err := row.Scan(
		&i.ID,
		&i.EnvironmentID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.Path,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEnvironment = `-- name: DeleteEnvironment :exec
DELETE FROM environments
WHERE id = $1
`

func (q *Queries) DeleteEnvironment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEnvironment, id)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteVariable = `-- name: DeleteVariable :exec
DELETE FROM variables
WHERE environment_id = $1 AND key = $2
`

type DeleteVariableParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Key           string      `json:"key"`
}

func (q *Queries) DeleteVariable(ctx context.Context, arg DeleteVariableParams) error {
	_, err := q.db.Exec(ctx, deleteVariable, arg.EnvironmentID, arg.Key)
	return err
}

const getEnvironment = `-- name: GetEnvironment :one
SELECT id, project_id, name, slug, created_at, updated_at FROM environments
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEnvironment(ctx context.Context, id pgtype.UUID) (Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironment, id)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProject = `-- name: GetProject :one
SELECT id, name, slug, description, created_at, updated_at FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectMember = `-- name: GetProjectMember :one
SELECT project_id, user_id, role, created_at FROM project_members
WHERE project_id = $1 AND user_id = $2
`

type GetProjectMemberParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetProjectMember(ctx context.Context, arg GetProjectMemberParams) (ProjectMember, error) {
	row := q.db.QueryRow(ctx, getProjectMember, arg.ProjectID, arg.UserID)
	var i ProjectMember
	err := row.Scan(
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, password_hash, full_name, password_reset_token, password_reset_expires_at, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, full_name, password_reset_token, password_reset_expires_at, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByResetToken = `-- name: GetUserByResetToken :one
SELECT id, email, password_hash, full_name, password_reset_token, password_reset_expires_at, created_at, updated_at FROM users
WHERE password_reset_token = $1 AND password_reset_expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetUserByResetToken(ctx context.Context, passwordResetToken pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByResetToken, passwordResetToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT id, project_id, name, slug, created_at, updated_at FROM environments
WHERE project_id = $1
ORDER BY name
`

func (q *Queries) ListEnvironments(ctx context.Context, projectID pgtype.UUID) ([]Environment, error) {
	rows, err := q.db.Query(ctx, listEnvironments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Environment
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectMembers = `-- name: ListProjectMembers :many
SELECT pm.project_id, pm.user_id, pm.role, pm.created_at, u.email, u.full_name
FROM project_members pm
JOIN users u ON pm.user_id = u.id
WHERE pm.project_id = $1
`

type ListProjectMembersRow struct {
	ProjectID pgtype.UUID        `json:"project_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Role      string             `json:"role"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Email     string             `json:"email"`
	FullName  string             `json:"full_name"`
}

func (q *Queries) ListProjectMembers(ctx context.Context, projectID pgtype.UUID) ([]ListProjectMembersRow, error) {
	rows, err := q.db.Query(ctx, listProjectMembers, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectMembersRow
	for rows.Next() {
		var i ListProjectMembersRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.Email,
			&i.FullName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT p.id, p.name, p.slug, p.description, p.created_at, p.updated_at, pm.role FROM projects p
JOIN project_members pm ON p.id = pm.project_id
WHERE pm.user_id = $1
ORDER BY p.created_at DESC
`

type ListProjectsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	Slug        string             `json:"slug"`
	Description pgtype.Text        `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Role        string             `json:"role"`
}

func (q *Queries) ListProjects(ctx context.Context, userID pgtype.UUID) ([]ListProjectsRow, error) {
	rows, err := q.db.Query(ctx, listProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsRow
	for rows.Next() {
		var i ListProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, full_name, password_reset_token, password_reset_expires_at, created_at, updated_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.PasswordResetToken,
			&i.PasswordResetExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariables = `-- name: ListVariables :many
SELECT id, environment_id, key, value, is_secret, path, created_at, updated_at FROM variables
WHERE environment_id = $1
ORDER BY key
`

func (q *Queries) ListVariables(ctx context.Context, environmentID pgtype.UUID) ([]Variable, error) {
	rows, err := q.db.Query(ctx, listVariables, environmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Variable
	for rows.Next() {
		var i Variable
		if err := rows.Scan(
			&i.ID,
			&i.EnvironmentID,
			&i.Key,
			&i.Value,
			&i.IsSecret,
			&i.Path,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectMember = `-- name: RemoveProjectMember :exec
DELETE FROM project_members
WHERE project_id = $1 AND user_id = $2
`

type RemoveProjectMemberParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) RemoveProjectMember(ctx context.Context, arg RemoveProjectMemberParams) error {
	_, err := q.db.Exec(ctx, removeProjectMember, arg.ProjectID, arg.UserID)
	return err
}

const setPasswordResetToken = `-- name: SetPasswordResetToken :exec
UPDATE users
SET password_reset_token = $2, password_reset_expires_at = $3
WHERE email = $1
`

type SetPasswordResetTokenParams struct {
	Email                  string             `json:"email"`
	PasswordResetToken     pgtype.Text        `json:"password_reset_token"`
	PasswordResetExpiresAt pgtype.Timestamptz `json:"password_reset_expires_at"`
}

func (q *Queries) SetPasswordResetToken(ctx context.Context, arg SetPasswordResetTokenParams) error {
	_, err := q.db.Exec(ctx, setPasswordResetToken, arg.Email, arg.PasswordResetToken, arg.PasswordResetExpiresAt)
	return err
}

const updateEnvironment = `-- name: UpdateEnvironment :one
UPDATE environments
SET name = $2, slug = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, project_id, name, slug, created_at, updated_at
`

type UpdateEnvironmentParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
	Slug string      `json:"slug"`
}

func (q *Queries) UpdateEnvironment(ctx context.Context, arg UpdateEnvironmentParams) (Environment, error) {
	row := q.db.QueryRow(ctx, updateEnvironment, arg.ID, arg.Name, arg.Slug)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password_hash = $2, password_reset_token = NULL, password_reset_expires_at = NULL
WHERE id = $1
`

type UpdatePasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash string      `json:"password_hash"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET name = $2, slug = $3, description = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, slug, description, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET email = $2, password_hash = $3, full_name = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, email, password_hash, full_name, password_reset_token, password_reset_expires_at, created_at, updated_at
`

type UpdateUserParams struct {
	ID           pgtype.UUID `json:"id"`
	Email        string      `json:"email"`
	PasswordHash string      `json:"password_hash"`
	FullName     string      `json:"full_name"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.PasswordResetToken,
		&i.PasswordResetExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVariable = `-- name: UpdateVariable :one
UPDATE variables
SET value = $3, is_secret = $4, path = $5, updated_at = CURRENT_TIMESTAMP
WHERE environment_id = $1 AND key = $2
RETURNING id, environment_id, key, value, is_secret, path, created_at, updated_at
`

type UpdateVariableParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Key           string      `json:"key"`
	Value         string      `json:"value"`
	IsSecret      pgtype.Bool `json:"is_secret"`
	Path          string      `json:"path"`
}

func (q *Queries) UpdateVariable(ctx context.Context, arg UpdateVariableParams) (Variable, error) {
	row := q.db.QueryRow(ctx, updateVariable,
		arg.EnvironmentID,
		arg.Key,
		arg.Value,
		arg.IsSecret,
		arg.Path,
	)
	var i Variable
	err := row.Scan(
		&i.ID,
		&i.EnvironmentID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.Path,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
